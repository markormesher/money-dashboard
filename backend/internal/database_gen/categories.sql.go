// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: categories.sql

package database_gen

import (
	"context"

	"github.com/google/uuid"
)

const getAllCategories = `-- name: GetAllCategories :many
SELECT
  category.id, category.name, category.is_memo, category.is_interest_income, category.is_dividend_income, category.is_capital_acquisition, category.is_capital_disposal, category.is_capital_event_fee, category.profile_id, category.active, category.is_synthetic_asset_update,
  profile.id, profile.name, profile.deleted
FROM
  category JOIN profile on category.profile_id = profile.id
WHERE
  profile.id = $1
`

type GetAllCategoriesRow struct {
	Category Category
	Profile  Profile
}

func (q *Queries) GetAllCategories(ctx context.Context, profileID uuid.UUID) ([]GetAllCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getAllCategories, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCategoriesRow
	for rows.Next() {
		var i GetAllCategoriesRow
		if err := rows.Scan(
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.IsMemo,
			&i.Category.IsInterestIncome,
			&i.Category.IsDividendIncome,
			&i.Category.IsCapitalAcquisition,
			&i.Category.IsCapitalDisposal,
			&i.Category.IsCapitalEventFee,
			&i.Category.ProfileID,
			&i.Category.Active,
			&i.Category.IsSyntheticAssetUpdate,
			&i.Profile.ID,
			&i.Profile.Name,
			&i.Profile.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryById = `-- name: GetCategoryById :one
SELECT
  category.id, category.name, category.is_memo, category.is_interest_income, category.is_dividend_income, category.is_capital_acquisition, category.is_capital_disposal, category.is_capital_event_fee, category.profile_id, category.active, category.is_synthetic_asset_update,
  profile.id, profile.name, profile.deleted
FROM
  category JOIN profile on category.profile_id = profile.id
WHERE
  category.id = $1
  AND profile.id = $2
`

type GetCategoryByIdParams struct {
	CategoryID uuid.UUID
	ProfileID  uuid.UUID
}

type GetCategoryByIdRow struct {
	Category Category
	Profile  Profile
}

func (q *Queries) GetCategoryById(ctx context.Context, arg GetCategoryByIdParams) (GetCategoryByIdRow, error) {
	row := q.db.QueryRow(ctx, getCategoryById, arg.CategoryID, arg.ProfileID)
	var i GetCategoryByIdRow
	err := row.Scan(
		&i.Category.ID,
		&i.Category.Name,
		&i.Category.IsMemo,
		&i.Category.IsInterestIncome,
		&i.Category.IsDividendIncome,
		&i.Category.IsCapitalAcquisition,
		&i.Category.IsCapitalDisposal,
		&i.Category.IsCapitalEventFee,
		&i.Category.ProfileID,
		&i.Category.Active,
		&i.Category.IsSyntheticAssetUpdate,
		&i.Profile.ID,
		&i.Profile.Name,
		&i.Profile.Deleted,
	)
	return i, err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO category (
  id,
  name,
  is_memo,
  is_interest_income,
  is_dividend_income,
  is_capital_acquisition,
  is_capital_disposal,
  is_capital_event_fee,
  is_synthetic_asset_update,
  profile_id,
  active
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
) ON CONFLICT (id) DO UPDATE SET
  id = $1,
  name = $2,
  is_memo = $3,
  is_interest_income = $4,
  is_dividend_income = $5,
  is_capital_acquisition = $6,
  is_capital_disposal = $7,
  is_capital_event_fee = $8,
  is_synthetic_asset_update = $9,
  profile_id = $10,
  active = $11
`

type UpsertCategoryParams struct {
	ID                     uuid.UUID
	Name                   string
	IsMemo                 bool
	IsInterestIncome       bool
	IsDividendIncome       bool
	IsCapitalAcquisition   bool
	IsCapitalDisposal      bool
	IsCapitalEventFee      bool
	IsSyntheticAssetUpdate bool
	ProfileID              uuid.UUID
	Active                 bool
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.Exec(ctx, upsertCategory,
		arg.ID,
		arg.Name,
		arg.IsMemo,
		arg.IsInterestIncome,
		arg.IsDividendIncome,
		arg.IsCapitalAcquisition,
		arg.IsCapitalDisposal,
		arg.IsCapitalEventFee,
		arg.IsSyntheticAssetUpdate,
		arg.ProfileID,
		arg.Active,
	)
	return err
}
