// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: reporting.sql

package database_gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/govalues/decimal"
)

const getDividendIncomeSumsPerHolding = `-- name: GetDividendIncomeSumsPerHolding :many
SELECT
  CAST(SUM(transaction.amount) AS NUMERIC(20, 10)) AS balance,
  transaction.holding_id
FROM
  transaction
    JOIN category on transaction.category_id = category.id
WHERE
  transaction.profile_id = $1
  AND transaction.date >= $2
  AND transaction.date <= $3
  AND transaction.deleted = FALSE
  AND category.is_dividend_income = TRUE
GROUP BY transaction.holding_id
`

type GetDividendIncomeSumsPerHoldingParams struct {
	ProfileID uuid.UUID
	MinDate   time.Time
	MaxDate   time.Time
}

type GetDividendIncomeSumsPerHoldingRow struct {
	Balance   decimal.Decimal
	HoldingID uuid.UUID
}

func (q *Queries) GetDividendIncomeSumsPerHolding(ctx context.Context, arg GetDividendIncomeSumsPerHoldingParams) ([]GetDividendIncomeSumsPerHoldingRow, error) {
	rows, err := q.db.Query(ctx, getDividendIncomeSumsPerHolding, arg.ProfileID, arg.MinDate, arg.MaxDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDividendIncomeSumsPerHoldingRow
	for rows.Next() {
		var i GetDividendIncomeSumsPerHoldingRow
		if err := rows.Scan(&i.Balance, &i.HoldingID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHoldingBalancesAsOfDate = `-- name: GetHoldingBalancesAsOfDate :many
SELECT
  CAST(SUM(transaction.amount) AS NUMERIC(20, 10)) AS balance,
  transaction.holding_id
FROM
  transaction
WHERE
  transaction.profile_id = $1
  AND transaction.date <= $2
  AND transaction.deleted = FALSE
GROUP BY transaction.holding_id
`

type GetHoldingBalancesAsOfDateParams struct {
	ProfileID uuid.UUID
	MaxDate   time.Time
}

type GetHoldingBalancesAsOfDateRow struct {
	Balance   decimal.Decimal
	HoldingID uuid.UUID
}

func (q *Queries) GetHoldingBalancesAsOfDate(ctx context.Context, arg GetHoldingBalancesAsOfDateParams) ([]GetHoldingBalancesAsOfDateRow, error) {
	rows, err := q.db.Query(ctx, getHoldingBalancesAsOfDate, arg.ProfileID, arg.MaxDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoldingBalancesAsOfDateRow
	for rows.Next() {
		var i GetHoldingBalancesAsOfDateRow
		if err := rows.Scan(&i.Balance, &i.HoldingID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHoldingBalancesChangesBetweenDates = `-- name: GetHoldingBalancesChangesBetweenDates :many
SELECT
  transaction.date,
  CAST(SUM(transaction.amount) AS NUMERIC(20, 10)) AS balance,
  transaction.holding_id
FROM
  transaction
WHERE
  transaction.profile_id = $1
  AND transaction.date >= $2
  AND transaction.date <= $3
  AND transaction.deleted = FALSE
GROUP BY transaction.date, transaction.holding_id
`

type GetHoldingBalancesChangesBetweenDatesParams struct {
	ProfileID uuid.UUID
	StartDate time.Time
	EndDate   time.Time
}

type GetHoldingBalancesChangesBetweenDatesRow struct {
	Date      time.Time
	Balance   decimal.Decimal
	HoldingID uuid.UUID
}

func (q *Queries) GetHoldingBalancesChangesBetweenDates(ctx context.Context, arg GetHoldingBalancesChangesBetweenDatesParams) ([]GetHoldingBalancesChangesBetweenDatesRow, error) {
	rows, err := q.db.Query(ctx, getHoldingBalancesChangesBetweenDates, arg.ProfileID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoldingBalancesChangesBetweenDatesRow
	for rows.Next() {
		var i GetHoldingBalancesChangesBetweenDatesRow
		if err := rows.Scan(&i.Date, &i.Balance, &i.HoldingID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInterestIncomeSumsPerHolding = `-- name: GetInterestIncomeSumsPerHolding :many
SELECT
  CAST(SUM(transaction.amount) AS NUMERIC(20, 10)) AS balance,
  transaction.holding_id
FROM
  transaction
    JOIN category on transaction.category_id = category.id
WHERE
  transaction.profile_id = $1
  AND transaction.date >= $2
  AND transaction.date <= $3
  AND transaction.deleted = FALSE
  AND category.is_interest_income = TRUE
GROUP BY transaction.holding_id
`

type GetInterestIncomeSumsPerHoldingParams struct {
	ProfileID uuid.UUID
	MinDate   time.Time
	MaxDate   time.Time
}

type GetInterestIncomeSumsPerHoldingRow struct {
	Balance   decimal.Decimal
	HoldingID uuid.UUID
}

func (q *Queries) GetInterestIncomeSumsPerHolding(ctx context.Context, arg GetInterestIncomeSumsPerHoldingParams) ([]GetInterestIncomeSumsPerHoldingRow, error) {
	rows, err := q.db.Query(ctx, getInterestIncomeSumsPerHolding, arg.ProfileID, arg.MinDate, arg.MaxDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInterestIncomeSumsPerHoldingRow
	for rows.Next() {
		var i GetInterestIncomeSumsPerHoldingRow
		if err := rows.Scan(&i.Balance, &i.HoldingID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoBalances = `-- name: GetMemoBalances :many
SELECT
  CAST(SUM(transaction.amount) AS NUMERIC(20, 10)) AS balance,
  holding.asset_id,
  holding.currency_id,
  transaction.category_id
FROM
  transaction
    JOIN holding ON transaction.holding_id = holding.id
    JOIN category ON transaction.category_id = category.id
WHERE
  transaction.profile_id = $1
  AND transaction.deleted = FALSE
  AND category.is_memo = TRUE
GROUP BY holding.asset_id, holding.currency_id, transaction.category_id
`

type GetMemoBalancesRow struct {
	Balance    decimal.Decimal
	AssetID    *uuid.UUID
	CurrencyID *uuid.UUID
	CategoryID uuid.UUID
}

func (q *Queries) GetMemoBalances(ctx context.Context, profileID uuid.UUID) ([]GetMemoBalancesRow, error) {
	rows, err := q.db.Query(ctx, getMemoBalances, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemoBalancesRow
	for rows.Next() {
		var i GetMemoBalancesRow
		if err := rows.Scan(
			&i.Balance,
			&i.AssetID,
			&i.CurrencyID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsForEnvelopeBalances = `-- name: GetTransactionsForEnvelopeBalances :many
SELECT
  transaction.id, transaction.date, transaction.budget_date, transaction.creation_date, transaction.payee, transaction.notes, transaction.amount, transaction.unit_value, transaction.holding_id, transaction.category_id, transaction.profile_id, transaction.deleted,
  category.id, category.name, category.is_memo, category.is_interest_income, category.is_dividend_income, category.is_capital_acquisition, category.is_capital_disposal, category.is_capital_event_fee, category.profile_id, category.active, category.is_synthetic_asset_update,
  profile.id, profile.name, profile.deleted,
  account.id, account.name, account.notes, account.is_isa, account.is_pension, account.exclude_from_envelopes, account.profile_id, account.active, account.account_group_id,
  transaction.holding_id
FROM
  transaction
    JOIN category on transaction.category_id = category.id
    JOIN profile on transaction.profile_id = profile.id
    JOIN holding on transaction.holding_id = holding.id -- not exposed - just used to join to accounts
    JOIN account ON holding.account_id = account.id
WHERE
  account.exclude_from_envelopes = FALSE
  AND transaction.profile_id = $1
  AND transaction.deleted = FALSE
`

type GetTransactionsForEnvelopeBalancesRow struct {
	Transaction Transaction
	Category    Category
	Profile     Profile
	Account     Account
	HoldingID   uuid.UUID
}

func (q *Queries) GetTransactionsForEnvelopeBalances(ctx context.Context, profileID uuid.UUID) ([]GetTransactionsForEnvelopeBalancesRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsForEnvelopeBalances, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsForEnvelopeBalancesRow
	for rows.Next() {
		var i GetTransactionsForEnvelopeBalancesRow
		if err := rows.Scan(
			&i.Transaction.ID,
			&i.Transaction.Date,
			&i.Transaction.BudgetDate,
			&i.Transaction.CreationDate,
			&i.Transaction.Payee,
			&i.Transaction.Notes,
			&i.Transaction.Amount,
			&i.Transaction.UnitValue,
			&i.Transaction.HoldingID,
			&i.Transaction.CategoryID,
			&i.Transaction.ProfileID,
			&i.Transaction.Deleted,
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.IsMemo,
			&i.Category.IsInterestIncome,
			&i.Category.IsDividendIncome,
			&i.Category.IsCapitalAcquisition,
			&i.Category.IsCapitalDisposal,
			&i.Category.IsCapitalEventFee,
			&i.Category.ProfileID,
			&i.Category.Active,
			&i.Category.IsSyntheticAssetUpdate,
			&i.Profile.ID,
			&i.Profile.Name,
			&i.Profile.Deleted,
			&i.Account.ID,
			&i.Account.Name,
			&i.Account.Notes,
			&i.Account.IsIsa,
			&i.Account.IsPension,
			&i.Account.ExcludeFromEnvelopes,
			&i.Account.ProfileID,
			&i.Account.Active,
			&i.Account.AccountGroupID,
			&i.HoldingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
